import{_ as K,r as _,b as ne,o as M,c as W,w as $,d as oe,e as X,f as U,j as f,k as I,s as se,a as ie,i as ae,q as ce,F as he}from"./index-e26bbf42.js";var de=Z,R=128,le=127,ue=~le,fe=Math.pow(2,31);function Z(r,e,t){e=e||[],t=t||0;for(var n=t;r>=fe;)e[t++]=r&255|R,r/=128;for(;r&ue;)e[t++]=r&255|R,r>>>=7;return e[t]=r|0,Z.bytes=t-n+1,e}var pe=D,we=128,j=127;function D(r,n){var t=0,n=n||0,o=0,s=n,i,c=r.length;do{if(s>=c)throw D.bytes=0,new RangeError("Could not decode varint");i=r[s++],t+=o<28?(i&j)<<o:(i&j)*Math.pow(2,o),o+=7}while(i>=we);return D.bytes=s-n,t}var be=Math.pow(2,7),ve=Math.pow(2,14),ye=Math.pow(2,21),ge=Math.pow(2,28),me=Math.pow(2,35),xe=Math.pow(2,42),Ee=Math.pow(2,49),Ae=Math.pow(2,56),Ce=Math.pow(2,63),Se=function(r){return r<be?1:r<ve?2:r<ye?3:r<ge?4:r<me?5:r<xe?6:r<Ee?7:r<Ae?8:r<Ce?9:10},_e={encode:de,decode:pe,encodingLength:Se},T=_e;const L=(r,e=0)=>[T.decode(r,e),T.decode.bytes],F=(r,e,t=0)=>(T.encode(r,e,t),e),O=r=>T.encodingLength(r),ke=(r,e)=>{if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0},G=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},ze=(r,e)=>{const t=e.byteLength,n=O(r),o=n+O(t),s=new Uint8Array(o+t);return F(r,s,0),F(t,s,n),s.set(e,o),new P(r,t,e,s)},Ue=r=>{const e=G(r),[t,n]=L(e),[o,s]=L(e.subarray(n)),i=e.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new P(t,o,i,e)},Be=(r,e)=>{if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&ke(r.bytes,t.bytes)}};class P{constructor(e,t,n,o){this.code=e,this.size=t,this.digest=n,this.bytes=o}}function Ve(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),i=s.charCodeAt(0);if(t[i]!==255)throw new TypeError(s+" is ambiguous");t[i]=o}var c=r.length,d=r.charAt(0),E=Math.log(c)/Math.log(256),l=Math.log(256)/Math.log(c);function A(a){if(a instanceof Uint8Array||(ArrayBuffer.isView(a)?a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength):Array.isArray(a)&&(a=Uint8Array.from(a))),!(a instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(a.length===0)return"";for(var u=0,z=0,w=0,v=a.length;w!==v&&a[w]===0;)w++,u++;for(var y=(v-w)*l+1>>>0,p=new Uint8Array(y);w!==v;){for(var g=a[w],S=0,b=y-1;(g!==0||S<z)&&b!==-1;b--,S++)g+=256*p[b]>>>0,p[b]=g%c>>>0,g=g/c>>>0;if(g!==0)throw new Error("Non-zero carry");z=S,w++}for(var m=y-z;m!==y&&p[m]===0;)m++;for(var V=d.repeat(u);m<y;++m)V+=r.charAt(p[m]);return V}function C(a){if(typeof a!="string")throw new TypeError("Expected String");if(a.length===0)return new Uint8Array;var u=0;if(a[u]!==" "){for(var z=0,w=0;a[u]===d;)z++,u++;for(var v=(a.length-u)*E+1>>>0,y=new Uint8Array(v);a[u];){var p=t[a.charCodeAt(u)];if(p===255)return;for(var g=0,S=v-1;(p!==0||g<w)&&S!==-1;S--,g++)p+=c*y[S]>>>0,y[S]=p%256>>>0,p=p/256>>>0;if(p!==0)throw new Error("Non-zero carry");w=g,u++}if(a[u]!==" "){for(var b=v-w;b!==v&&y[b]===0;)b++;for(var m=new Uint8Array(z+(v-b)),V=z;b!==v;)m[V++]=y[b++];return m}}}function re(a){var u=C(a);if(u)return u;throw new Error(`Non-${e} character`)}return{encode:A,decodeUnsafe:C,decode:re}}var $e=Ve,Ne=$e;class Me{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Ie{constructor(e,t,n){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Y(this,e)}}class Te{constructor(e){this.decoders=e}or(e){return Y(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Y=(r,e)=>new Te({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Fe{constructor(e,t,n,o){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=o,this.encoder=new Me(e,t,n),this.decoder=new Ie(e,t,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const ee=({name:r,prefix:e,encode:t,decode:n})=>new Fe(r,e,t,n),te=({prefix:r,name:e,alphabet:t})=>{const{encode:n,decode:o}=Ne(t,e);return ee({prefix:r,name:e,encode:n,decode:s=>G(o(s))})},Oe=(r,e,t,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let c=0,d=0,E=0;for(let l=0;l<s;++l){const A=o[r[l]];if(A===void 0)throw new SyntaxError(`Non-${n} character`);d=d<<t|A,c+=t,c>=8&&(c-=8,i[E++]=255&d>>c)}if(c>=t||255&d<<8-c)throw new SyntaxError("Unexpected end of data");return i},De=(r,e,t)=>{const n=e[e.length-1]==="=",o=(1<<t)-1;let s="",i=0,c=0;for(let d=0;d<r.length;++d)for(c=c<<8|r[d],i+=8;i>t;)i-=t,s+=e[o&c>>i];if(i&&(s+=e[o&c<<t-i]),n)for(;s.length*t&7;)s+="=";return s},x=({name:r,prefix:e,bitsPerChar:t,alphabet:n})=>ee({prefix:e,name:r,encode(o){return De(o,n,t)},decode(o){return Oe(o,n,t,r)}}),k=te({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});te({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const N=x({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});x({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});x({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});x({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});x({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});x({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});x({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});x({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});x({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const J=(r,e)=>{const{bytes:t,version:n}=r;switch(n){case 0:return qe(t,q(r),e||k.encoder);default:return Ge(t,q(r),e||N.encoder)}},Q=new WeakMap,q=r=>{const e=Q.get(r);if(e==null){const t=new Map;return Q.set(r,t),t}return e};class h{constructor(e,t,n,o){this.code=t,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==B)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Pe)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return h.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=ze(e,t);return h.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return h.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&Be(e.multihash,n.multihash)}toString(e){return J(this,e)}toJSON(){return{"/":J(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof h)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:o,multihash:s,bytes:i}=t;return new h(n,o,s,i||H(n,o,s.bytes))}else if(t[Re]===!0){const{version:n,multihash:o,code:s}=t,i=Ue(o);return h.create(n,s,i)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==B)throw new Error(`Version 0 CID must use dag-pb (code: ${B}) block encoding`);return new h(e,t,n,n.bytes)}case 1:{const o=H(e,t,n.bytes);return new h(e,t,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return h.create(0,B,e)}static createV1(e,t){return h.create(1,e,t)}static decode(e){const[t,n]=h.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=h.inspectBytes(e),n=t.size-t.multihashSize,o=G(e.subarray(n,n+t.multihashSize));if(o.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=o.subarray(t.multihashSize-t.digestSize),i=new P(t.multihashCode,t.digestSize,s,o);return[t.version===0?h.createV0(i):h.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[A,C]=L(e.subarray(t));return t+=C,A};let o=n(),s=B;if(o===18?(o=0,t=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const i=t,c=n(),d=n(),E=t+d,l=E-i;return{version:o,codec:s,multihashCode:c,digestSize:d,multihashSize:l,size:E}}static parse(e,t){const[n,o]=Le(e,t),s=h.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return q(s).set(n,e),s}}const Le=(r,e)=>{switch(r[0]){case"Q":{const t=e||k;return[k.prefix,t.decode(`${k.prefix}${r}`)]}case k.prefix:{const t=e||k;return[k.prefix,t.decode(r)]}case N.prefix:{const t=e||N;return[N.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}},qe=(r,e,t)=>{const{prefix:n}=t;if(n!==k.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const o=e.get(n);if(o==null){const s=t.encode(r).slice(1);return e.set(n,s),s}else return o},Ge=(r,e,t)=>{const{prefix:n}=t,o=e.get(n);if(o==null){const s=t.encode(r);return e.set(n,s),s}else return o},B=112,Pe=18,H=(r,e,t)=>{const n=O(r),o=n+O(e),s=new Uint8Array(o+t.byteLength);return F(r,s,0),F(e,s,n),s.set(t,o),s},Re=Symbol.for("@ipld/js-cid/CID"),je={},Je=f("div",{style:{margin:"5px"}},[f("p",null,[I("ElfinGuard Gateway is a new kind of IPFS Gateway. Instead of downloading files from IPFS, it helps you view the files published to IPFS using the "),f("a",{href:"https://elfinguard.org"},"ElfinGuard Access-Control"),I(" protocol.")]),f("br"),f("p",null,"As an author, you can choose one of the following ways to control who are authorized to view your work:"),f("p",null,'1. The audience must own enough tokens as you require. If you have issued some ERC20 token or NFT, you can require the target audience to these tokens. Each token has a "score" value. The audience can view any of your file at any time, as long as they own enough tokens whose accumulated score value is larger than a given threshold. '),f("p",null,"2. The audience must pay you some BCH to view a file from now on, for unlimited times. To prevent account sharing, it is suggested that you also require the audience to own some tokens, at least the native token used to pay gas fee, such as BCH on the smartBCH chain, and BNB on BSC."),f("p",null,"3. The audience must pay you a small amount of BCH at a low probability to view the file only once. It is like a lucky draw for you: The audience give the payment transaction to a trustable online judger, who will decide whether to broadcast the transaction or forget it. This scheme is called stochastic payment."),f("br"),f("p",null,"If you are an audience, ElfinGuard Gateway will download the published file from IPFS, extract the author's requirement, check whether you have owned enough tokens to reach the score threshold, and help you pay BCH to the author.")],-1);function Qe(r,e){const t=_("van-nav-bar"),n=_("van-popup"),o=ne("responsive-popup");return M(),W(n,{show:!0,position:"left",style:{width:"100%",height:"100%"}},{default:$(()=>[oe((M(),X("div",null,[U(t,{title:"About","left-text":"Back","left-arrow":"",onClickLeft:e[0]||(e[0]=s=>r.$emit("back"))})])),[[o]]),Je]),_:1})}const He=K(je,[["render",Qe]]),Ke={components:{About:He},data(){return{store:se,input:"",showAbout:!1}},methods:{search(){try{const r=h.parse(this.input)}catch{ie("invalid cid");return}this.$router.push({name:"view",params:{cid:this.input}})}}},We={class:"header"},Xe={class:"input"},Ze={class:"about",style:{"text-align":"right","margin-top":"50px","margin-right":"8px"}};function Ye(r,e,t,n,o,s){const i=_("van-nav-bar"),c=_("van-button"),d=_("van-field"),E=_("van-cell-group"),l=_("van-icon"),A=_("About");return M(),X(he,null,[f("div",We,[U(i,{title:"ElfinGuard Gateway"})]),f("div",Xe,[U(E,{inset:"",style:{"margin-top":"100px"}},{default:$(()=>[U(d,{modelValue:o.input,"onUpdate:modelValue":e[0]||(e[0]=C=>o.input=C),center:"",clearable:"",placeholder:"Please input IPFS CID:"},{button:$(()=>[U(c,{size:"small",type:"primary",onClick:s.search,plain:""},{default:$(()=>[I("View")]),_:1},8,["onClick"])]),_:1},8,["modelValue"])]),_:1})]),f("div",Ze,[f("a",{href:"#",onClick:e[1]||(e[1]=ae(C=>o.showAbout=!0,["prevent","stop"]))},[I("About ElfinGuard GateWay"),U(l,{name:"arrow"})])]),o.showAbout?(M(),W(A,{key:0,onBack:e[2]||(e[2]=C=>o.showAbout=!1)})):ce("",!0)],64)}const tt=K(Ke,[["render",Ye]]);export{tt as default};
